# Path - ãäå õðàíèì áèáëèîòåêè
# Mail - ïî÷òà àäìèíèñòðàòîðà
# Domain - äîìåí äëÿ êîòîðîãî ïîëó÷àåì ñåðòèôèêàò
# PfxPassword - пароль для Pfx
$Path = "C:\certes"
$Mail = "mailto:admin@contoso.ru"
$Domain = "*.contoso.ru"
$PfxFriendlyName = "CONTOSO_{0}" -f (Get-Date).AddMonths(3).ToString("MMyy")
$PfxPath = Join-Path $Path "wildcard_cert.pfx"
$PfxPassword = "12345678"

# Ññûëêè äëÿ ñêà÷èâàíèÿ nupkg
$Urls = (
	"https://www.nuget.org/api/v2/package/Certes",
	"https://www.nuget.org/api/v2/package/BouncyCastle.Crypto.dll",
	"https://www.nuget.org/api/v2/package/Newtonsoft.Json"
)

# Óêàçûâàåì áèáëèîòåêè äëÿ ïðîâåðêè
$Dlls = (
	"$Path\lib\net45\Certes.dll",
	"$Path\lib\BouncyCastle.Crypto.dll",
	"$Path\lib\net45\Newtonsoft.Json.dll"
)


# Ñîçäàåì ïàïêó
if( -not (Test-Path $path) ) {
	New-Item -Type Directory -Path $path | Out-Null
}

Test-Path $Dlls | Where-Object {-not $_} | Foreach-Object { 
	$Urls | Foreach-Object {
		# Ñêà÷èâàåì nupkg
		$r = Invoke-WebRequest $_ -UseBasicParsing
		$filename = Join-Path $path $r.BaseResponse.ResponseUri.Segments[-1]
		[System.IO.File]::WriteAllBytes($filename,$r.Content)

		# Ðàñïàêîâûâàåì nupkg
		Expand-Archive $filename  -OutputPath $path -Force
	}
}

# Óäàëèì ëèøíåå
Get-ChildItem $path | Where {$_.Name -ne "lib"} | Remove-Item -Force -Recurse

# Ïîäãðóçè áèáëèîòåêè
$Dlls | Foreach-Object {
	[System.Reflection.Assembly]::LoadFile($_) | Out-Null
}


# Ñîçäàäèì ó÷åòíóþ çàïèñü
# Äëÿ òåñòîâîãî èñïîëüçîâàíèÿ LetsEncryptStagingV2
$context = [Certes.AcmeContext]::new([Certes.Acme.WellKnownServers]::LetsEncryptV2)
$context.Result
$account = $context.NewAccount([System.Collections.Generic.List[string]]$Mail, $true)
$account.Result

# Ôîðìèðóåì çàïðîñ íà ïîëó÷åíèå wildcard
$order = $context.NewOrder([Collections.Generic.List[string]]$Domain)
$authz = $order.Result.Authorizations()
$dnsChallenge = $authz.Result.Resource().Result.Challenges

# Ñîäåðæèò token äëÿ DNS çàïèñè _acme-challenge.contoso.com
$dnsTxt = [Certes.ISignatureKeyExtensions]::DnsTxt($context.AccountKey,$dnsChallenge.Token)

# Ñîçäàåì ðåñóðñíûå çàïèñè 
# Windows DNS Server
$DomainName = $Domain.Replace("*.","")
$Name = "_acme-challenge"
$record = Get-DnsServerResourceRecord -ZoneName $DomainName -Name $Name -RRType Txt

if($record)
{
	$newrecord = $record.Clone()
	$newrecord.RecordData.DescriptiveText = $_.RecordValue
	Set-DnsServerResourceRecord -ZoneName $DomainName -NewInputObject $newrecord -OldInputObject $record
}
else
{
	Add-DnsServerResourceRecord -ZoneName $DomainName -Txt -Name $Name -DescriptiveText $dnsTxt
}


# Ïîëó÷àåì ñåðòèôèêàò
if($dnsTxt) {
	# Îòïðàâëÿåì çàïðîñ íà ïðîâåðêó DNS çàïèñè
	$validatetatus = $authz.Result.Challenges().Result.Validate()
	$validatetatus.Result
	
	# Finalize
	$csr = [Certes.Pkcs.CertificationRequestBuilder]::new()
	$csr.AddName("CN=$Domain")
	$order.Result.Finalize($csr.Generate())
	
	# Ñêà÷èâàåì öåïî÷êó ñåðòèôèêàòîâ
	$certChain = $order.Result.Download()
	$cert = $certChain.Result
		
	# Ýêñïîðò â Pfx
	$certKey = [Certes.KeyFactory]::NewKey("RS256")
	$pfx = [Certes.CertificateChainExtensions]::ToPfx($cert,$certKey)
	$pfxcert = $pfx.Build($PfxFriendlyName, $PfxPassword)
	[System.IO.File]::WriteAllBytes($PfxPath,$pfxcert)
}

# Îòçûâ ñåðòèôèêàòà
# $context.RevokeCertificate($cert.Certificate.ToDer(), [Certes.Acme.Resource.RevocationReason]::KeyCompromise,$null)
